#!/bin/bash

set -euC

color() {
  case $1 in
    black)    echo -e -n "\033[1;30m";;
    red)      echo -e -n "\033[1;31m";;
    green)    echo -e -n "\033[1;32m";;
    yellow)   echo -e -n "\033[1;33m";;
    blue)     echo -e -n "\033[1;34m";;
    magenta)  echo -e -n "\033[1;35m";;
    cyan)     echo -e -n "\033[1;36m";;
    white)    echo -e -n "\033[1;37m";;
    *)        echo -e -n "\033[0m";;
  esac
}

status() {
  local flags=''
  # Modified
  if ! git diff --no-ext-diff --quiet; then
    flags="*$flags"
  fi

  # Cached
  if ! git diff --no-ext-diff --cached --quiet; then
    flags="~$flags"
  fi

  # Stash
  if git rev-parse --verify --quiet refs/stash >/dev/null; then
    flags="\$$flags"
  fi

  # Untracked
  if git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; then
    flags="…$flags"
  fi

  echo "$flags"
}

branch() {
  local branch=$(git describe --contains --all HEAD)
  echo $branch
}

hash() {
  git log --pretty=format:'%h' -n 1
}

prompt() {
  local b=" $(branch)"
  local s=$(status); s=${s:+ $s}
  # local h=$(hash)
  local colorcode=42
  color white
  if [[ $s =~ .*\*.* ]]; then
    colorcode=41
  elif [[ $s =~ .*~.* ]]; then
    colorcode=43
  fi
  echo -e -n "\[\e[30;${colorcode}m\]\[\e[${colorcode}m\]"
  echo -n " $b$s "
  echo -e -n "\[\e[$(($colorcode - 10));49m\]\[\e[0m\] "
}

git_ps() {
  if git rev-parse &>/dev/null; then
    prompt
  else
    return
  fi
}

if [[ ${BASH_SOURCE[0]} == $0 ]]; then
  git_ps
fi
